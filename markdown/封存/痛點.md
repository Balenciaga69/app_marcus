[這份文章是 GPT 產生的 參考就好, 與現實需求可能有差異]

「以痛為師」——模擬真實專案成長曲線、每階段都踩痛點再升級。
我幫你規劃成 **五階段進化路線圖（Order/Payment 系統）**，每階段都有：

- 🎯 學習目標
- 🧱 架構變化
- 💥 預期痛點（你要「刻意踩到」）
- 🧰 該練的工具與知識點
- 🚀 進階條件（痛點觸發 → 進入下一階段）

---

## 🩱 **Phase 1：單體基礎版（CRUD 實作階段）**

> **目標**：熟悉 NestJS 架構與 ORM、打好 domain model，初步掌握交易流程。

### 🎯 學習目標

- NestJS 架構（Controller → Service → Repository）
- TypeORM / Prisma 調教與效能觀察
- 資料表關聯與交易處理（order, user, payment）
- REST API 設計

### 🧱 架構

- 單一 NestJS 專案
- PostgreSQL + TypeORM
- REST API

### 💥 痛點模擬

1. ORM 自動生成 SQL 效能差
2. Transaction 失敗 rollback 行為不如預期
3. N+1 Query 問題導致效能低落

### 🧰 工具與練習

- `typeorm` / `prisma` + `pg_stat_statements`
- `EXPLAIN ANALYZE` / Query optimization
- Jest + Supertest（簡單單元測試）

### 🚀 進階條件

當你「開始不滿 ORM 查詢速度」或「需要跨 transaction 操作」，進入 Phase 2。

---

## ⚙️ **Phase 2：分層與快取優化（性能優化階段）**

> **目標**：解決單體效能痛點，導入 cache 與分層架構。

### 🎯 學習目標

- Repository Pattern / Clean Architecture
- Redis cache / Lock / PubSub
- 簡易 APM 與 log trace

### 🧱 架構

- 同樣是單體，但分層明確（Domain / Infra / App 層）
- Redis 整合 cache / 鎖 / PubSub

### 💥 痛點模擬

1. 熱門商品下單搶購 → 超賣問題
2. Redis cache 失效風暴
3. 同步 transaction + cache 不一致

### 🧰 工具與練習

- Redis `setnx` / `redlock` / TTL
- `pino` / `winston` 結構化 logging
- k6 / Artillery 壓測

### 🚀 進階條件

當你「需要非同步事件」或「單體難以 scale」時 → 進入 Phase 3。

---

## 🧨 **Phase 3：微服務拆分與事件驅動（EDA 實戰）**

> **目標**：體驗微服務通訊與資料一致性挑戰。

### 🎯 學習目標

- Kafka / RabbitMQ 事件驅動模型
- Outbox / SAGA Pattern
- 微服務通訊模式（Event-driven, Request-response）
- API Gateway 基礎

### 🧱 架構

- Service：Order / Payment / Inventory / Notification
- Kafka 或 RabbitMQ 為中介
- API Gateway（NestJS Gateway 模組）

### 💥 痛點模擬

1. 消息重複投遞、延遲、順序錯亂
2. 資料最終一致性問題（訂單已扣款但庫存沒減）
3. Kafka partition rebalancing 導致消費中斷

### 🧰 工具與練習

- KafkaJS / amqplib / Nest Microservice transport
- Outbox pattern（DB → Kafka）
- Dead Letter Queue / Retry 機制

### 🚀 進階條件

當你「需要追蹤整條交易流、Debug 困難」→ 進入 Phase 4。

---

## 🧭 **Phase 4：可觀測性與 CI/CD（穩定性工程階段）**

> **目標**：打造可維運、可觀測、可自動化部署的系統。

### 🎯 學習目標

- OpenTelemetry / Grafana Tempo 追蹤請求流
- Filebeat / ElasticSearch / Loki 收集 log
- GitHub Actions / GitLab CI/CD pipeline

### 🧱 架構

- 各服務 containerized
- CI/CD pipeline 自動測試與部署
- 監控 + 追蹤整合

### 💥 痛點模擬

1. 無法快速追蹤跨服務錯誤來源
2. Log 過量 / trace ID 無法串聯
3. pipeline fail 時 debug 成本高

### 🧰 工具與練習

- `otel-js` + `Grafana Tempo` + `Prometheus`
- Elastic Stack (ELK)
- Docker Compose + CI/CD pipeline

### 🚀 進階條件

當你「知道系統穩定但效能上不去」→ 進入 Phase 5。

---

## 🔥 **Phase 5：高併發與壓力測試（極限挑戰階段）**

> **目標**：模擬真實大流量，體驗可擴展性與瓶頸分析。

### 🎯 學習目標

- 高併發壓測與 Scaling 策略
- Cache 層級設計（multi-layer cache）
- Circuit Breaker / Bulkhead / Retry Pattern
- 分散式鎖與 rate limit

### 🧱 架構

- 多服務 / 多副本 / 可水平擴展
- 使用 k6 模擬高流量、觀測瓶頸

### 💥 痛點模擬

1. 熱點鍵導致 Redis 壅塞
2. Kafka lag 堆積
3. Node event loop 被阻塞
4. API Gateway throughput 不穩

### 🧰 工具與練習

- `k6`, `Artillery`
- `pm2`, `Nginx` load balancing
- 分析 Node event loop delay
- Grafana dashboard 觀測 QPS

---

## 🧠 最終結果

完成這五階段後，你會有：

- 可展示於面試的完整系統（單體 → 微服務 → 可觀測 → 可擴展）
- 每階段的痛點筆記與瓶頸報告
- 一份能說「我實作過分散式交易、一致性、事件追蹤」的作品

---

## 專案

### 主要目的

基於多次面試被考倒，工作用的技術堆疊又不能實踐的功能。於是痛定思痛，開始打造一或多 SideProject 能學習並涵蓋大部分面試內容。

### 想要練習的點

- SQL 調教/ORM 調教/優化
- Redis 分散式與優化相關知識
- RabbitMQ 知識
- Kafka 知識
- 單體與微服務比較痛點與實踐知識
- 設計模式實踐
- 單元測試實踐
- CI/CD 成熟化實踐
- ElasticSearch, FileBeat, Grafana, OpenTelemetry
- DDD/Clean 架構與代碼
- EDA 事件驅動
- 物件導向思考
- 併發大流量思考與壓力測試
- Config / Secret / 環境管理策略
- API Gateway / 微服務通訊模式
- Transactional consistency 與資料同步

### 個人偏好

- 即將面試的公司使用 NestJS
- 透過 TypeScript 理解 JS 生態圈與乾淨代碼實踐
- 使用 PostgreSQL 作為主要資料庫且體驗其調教與優化過程
- 我不想管業務邏輯，而是解決技術痛點。
- 每個階段都開一個 git tag 標記版本，方便回顧與展示各階段最終成果。

## 可能的痛點

- 工具重疊：RabbitMQ/Kafka 擇一；k6/Artillery 擇一。
- 架構限制：微服務拆分本地難模擬；高併發需雲端。
- 資源限制：Windows 本地設置 Kafka/ElasticSearch 困難。
- 時間限制：無法全實踐，優先核心技術點。
- 環境差異：本地 vs 雲端測試效果不同。

---
